use std::collections::HashSet;

pub fn run() {
    let input = std::fs::read_to_string("inputs/day04.txt").unwrap();
    let parsed_input = input.lines()    
        .map(|line| line.chars()
            .map(|c| match c {
                '.' => Cell::Empty,
                '+' => Cell::Forklift,
                '@' => Cell::Paperroll,
                _ => panic!("Unknown cell type"),
            })
            .collect::<Vec<Cell>>()
        )
        .collect::<Vec<Vec<Cell>>>();
    println!("Day 04 – Part 1: {}", part1(&parsed_input));
    println!("Day 04 – Part 2: {}", part2(&parsed_input));
}

enum Cell {
    Empty, 
    Forklift,
    Paperroll
}

fn collect_accessibles(grid: &[Vec<Cell>], x: usize, y: usize, paperrolls: &HashSet<(usize, usize)>) -> bool {
    let cell = &grid[x][y];
    if !matches!(cell, Cell::Forklift) {
        return false; 
    }

    // check neighbors for forklift 
    let neighbors: [(isize, isize); 8] = [
        (-1, -1), (-1, 0), (-1, 1),
        (0, -1),           (0, 1),
        (1, -1),  (1, 0),  (1, 1),
    ];
    for &(dx, dy) in neighbors.iter() {
        let nx = (x as isize) + dx;
        let ny = (y as isize) + dy;
        
        if nx < 0 || ny < 0 || 
            nx >= (grid.len() as isize) ||
            ny >= (grid[0].len() as isize) ||
            !matches!(grid[nx as usize][ny as usize], Cell::Paperroll) {
                return false; 
        } 

        paperrolls.insert((nx as usize, ny as usize));
    } 

    true
}

fn part1(grid: &[Vec<Cell>]) -> usize {
    let mut paperrolls = HashSet::new(); 
    
    for i in 0..grid.len() {
        for j in 0..grid[0].len() {
            collect_accessibles(grid, j, i, &paperrolls);  
        }
    }

    paperrolls.len()
}

fn part2(grid: &[Vec<Cell>]) -> i64 {
    0
}

// use std::collections::HashSet;
// // Type inference lets us omit an explicit type signature (which
// // would be `HashSet<String>` in this example).
// let mut books = HashSet::new();

// // Add some books.
// books.insert("A Dance With Dragons".to_string());
// books.insert("To Kill a Mockingbird".to_string());
// books.insert("The Odyssey".to_string());
// books.insert("The Great Gatsby".to_string());

// // Check for a specific one.
// if !books.contains("The Winds of Winter") {
//     println!("We have {} books, but The Winds of Winter ain't one.",
//              books.len());
// }

// // Remove a book.
// books.remove("The Odyssey");

// // Iterate over everything.
// for book in &books {
//     println!("{book}");
// }
